'use strict';

var vscode = require('vscode');
class codeBlock{
    constructor(parentCodeBlock,level){
        this.parentCodeBlock = parentCodeBlock || null; // Will be an object but setting it to null for now
        this.childCodeBlockElements = new Array(); // Array of codeBlockElements objects
        this.level = level || 1;// block level
    }
}


class codeBlockElements {
    constructor(){
        this.key = null; // String value
        //keyname string
        this.value = null; //Sting of the value
        this.codeBlockValue = null; // Will be object but set to null for now
        this.isRoot = false;// Is root element
        this.blockType = null; // Type of block (array or object)
        this.parentCodeBlock = null; // Not referenced in build loop
        this.level = 1;// block level
    }
    set key(keyname){//remove keyname with only numbers

        if(typeof keyname == 'string' && keyname.search(/^[0-9]*$/) == -1){
            this._key = keyname;
        }else {
            this._key = null;
        }
        return;
    }
    get key(){
        return this._key;
    }
    set value(value){
        if(typeof value == "string"){
            this._value = escapeString(value);
        }else{
            this._value = value;
        }
    }
    get value(){
        return this._value;
    }
    set blockType(property){
        var blockType;
        var objectType = Object.prototype.toString.call(property);
        var regex = /[[a-zA-z]+ ([a-zA-z]+)]/;//RegEpx to finf value type from [object (String)]
        if((blockType = regex.exec(objectType)) !== null){
            this._blockType = blockType[1];// String, Array, or Object
        }
    }
    get blockType(){
        return this._blockType;
    }
    rootCodeBlock(){
        var rootCodeBlock = this.parentCodeBlock;
        var root = false;
        /**/
        while (root == false) {
            if(rootCodeBlock.parentCodeBlock !== null){
               rootCodeBlock = rootCodeBlock.parentCodeBlock; 
            }else{
                var root = true;
            }
            
            
        }
        return rootCodeBlock;
    }
}

class JSONConstructor {
    
    constructor(rootCodeBlock){
        this.rootCodeBlock = rootCodeBlock;
    }
    //JSON Parser function
    buildIterator(useCodeBlock,object) {
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var newCodeBlockElement = this.createCodeBlockElement(useCodeBlock,object,property);
                if(newCodeBlockElement){                    
                    this.buildIterator(newCodeBlockElement,object[property]);// If childeren blocks
                }
            }
        }
        return useCodeBlock;
    }
    createCodeBlock(useCodeBlock,currentCodeBlockElement){
        var newCodeBlock = new codeBlock();//New codeBlock object
        newCodeBlock.parentCodeBlock = currentCodeBlockElement;// Set propery to referance parent codeBlock
        newCodeBlock.level = useCodeBlock.level + 1;//Set clodeBlockElement level plus 1

        return newCodeBlock;
    }
    createCodeBlockElement(useCodeBlock,obj,prop){
        var objectType = Object.prototype.toString.call(obj[prop]);

        var currentCodeBlockElement = new codeBlockElements();// Create new codeBlockElement
        currentCodeBlockElement.key = prop;
        
        currentCodeBlockElement.keyLength = (prop.length+2);
        currentCodeBlockElement['is' + (prop.charAt(0).toUpperCase() + prop.slice(1)).replace('-','')] = true;// Dynamic isKeyname property

        currentCodeBlockElement.blockType = obj[prop];// Get object type
        
        currentCodeBlockElement.parentCodeBlock = useCodeBlock;
        currentCodeBlockElement.level = useCodeBlock.level;// Block level
        currentCodeBlockElement.value = obj[prop];//
        
        if(objectType === '[object Object]' || objectType === '[object Array]'){
            currentCodeBlockElement.value = null;//set to null if codeBlockElement
            var newCodeBlock = this.createCodeBlock(useCodeBlock,currentCodeBlockElement);
            currentCodeBlockElement.codeBlockValue = newCodeBlock;// Add new codeBlockElement
        }

        useCodeBlock.childCodeBlockElements.push(currentCodeBlockElement);// Add codeBlockElement to parent codeBlock object

        return newCodeBlock || null;
    }
}

//Look into the children array
function formatJSON(jsonCodeBlock) {   
    var generateJSONString = '';
    let specialFormatKeys = [ //Special formating keyname
        'isTasks',
        'isHappening',
        'isGoals',
        'isAllOf',
        'isChoices',
        'isChoice',
        'isXchoices',
        'isForeignKeys',
        'isSerialize',
        'isIndexes',
        'isAllof',
        'isContextValues',
        'isComputeds',
        'isOneOf'

    ];

    for (var i = 0, elementCount = jsonCodeBlock.childCodeBlockElements.length; i < elementCount; i++) {

        var currentElement = jsonCodeBlock.childCodeBlockElements[i]; // Current Object
        var currentLevel = currentElement.parentCodeBlock.level; // Current level
        var currentColonPosition = currentElement.keyLength;// keyname length
        var currentElementProp = Object.getOwnPropertyNames(currentElement);

        var blkLrgKeyLen = currentElement.parentCodeBlock.childCodeBlockElements;
        
        var highestLevelCurrent = [];
        for (var loop = 0; loop < blkLrgKeyLen.length; loop++) {
            highestLevelCurrent.push(blkLrgKeyLen[loop].keyLength)
        }
        
        var curLrgKeyLength = Math.max.apply(Math,highestLevelCurrent);// Find the largest value/Level
        
        if(curLrgKeyLength < 12){
            curLrgKeyLength = 14;
        }

        //length of padding (currentElements keyname length minus largest value in codeBlock.Children.level)
        var lengthOfPadding = Math.abs(currentColonPosition - curLrgKeyLength); 

        

        var leftSpace = '';
        for (var index = 0; index < lengthOfPadding; index++) {// Loop over padding length add space for each count
            leftSpace += ' '; 
        }

        /**/
        var rootBlkLrgKeyLen = currentElement.rootCodeBlock();
        rootBlkLrgKeyLen = rootBlkLrgKeyLen.childCodeBlockElements;
        
        var addSpace = '\t';
        
        var spaceIndentation = '';
        /*Add left indentation*/
        if(currentLevel > 1){}
            var lelSpc = ((currentLevel)*2);
            var sIndex = 0;
            while (sIndex < lelSpc) {
                //smaller spaces for sub level indentation
                //spaceIndentation += '    ';
                sIndex++;
            }
            var spIndex = 0;
            while (spIndex < currentLevel) {
                //smaller spaces for sub level indentation
                spaceIndentation += '       ';
                spIndex++;
            }

        /**
         * Keyname building
         */
        if(currentElement.key){// Check if key is set
            generateJSONString += spaceIndentation + leftSpace + '"' + currentElement.key + '": ';
        }

        /**
         * Value building
         */
        if(currentElement.value !== null){// Check if value set
            generateJSONString += currentElement.value;
            generateJSONString += newline(i,elementCount,currentElement.key);
        }
        

        /*         */
        if(currentElement.codeBlockValue !== null && currentElement.codeBlockValue.childCodeBlockElements.length > 0){
            
            if(currentElement.blockType == 'Array'){
                if(isKeyname(currentElementProp,specialFormatKeys)){
                    generateJSONString += '[\n';
                }else{
                    if(!currentElement.key){
                        generateJSONString += spaceIndentation + addSpace;
                    }
                    generateJSONString += '[';
                }

                generateJSONString += formatJSON(currentElement.codeBlockValue);

                if(isKeyname(currentElementProp,specialFormatKeys)){
                    generateJSONString += spaceIndentation + addSpace;
                }
                
                generateJSONString += ']';
                

                generateJSONString += newline(i,elementCount,true);

            }

            if(currentElement.blockType == 'Object'){


                if(!currentElement.key){
                    generateJSONString += spaceIndentation + addSpace + '';
                }

                generateJSONString += '{\n';

                generateJSONString += formatJSON(currentElement.codeBlockValue);
                
                generateJSONString += spaceIndentation + addSpace;

                /**/
                if(!currentElement.key){
                    generateJSONString += '';
                }
                
                generateJSONString += '}';

                generateJSONString += newline(i,elementCount,true);
            }
            
        }
        
    }

    return generateJSONString;
}

function newline(index, length, boolean) {
    var returnStr;
    if((index+1) < length){
        if(boolean){// Does key only have numbers?
            returnStr = ',\n';
        }else {
            returnStr = ', ';
        }
    } else {
        if(boolean){// Does key only have numbers?
            returnStr = '\n';
        }else {
            returnStr = '';
        }
    }
    return returnStr;
}

function isKeyname(properties,specialFormatKeys) {
    for (var key in specialFormatKeys) {
        var found = properties.indexOf(specialFormatKeys[key]);
        if(found > -1) return true;
    }
}

function escapeString(value) {
    return value.replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/\t/g, "\\t")
        .replace(/\f/g, "\\f");
        //.replace(/\&/g, "\\&")
}

function valueType(key, value){
    switch (typeof value) {
        case 'string':
            return '"' + String(value) + '"';
            break;
        case 'number':
            return Number(value);
            break;
        default:
            return value;
            break;
    }
}


function str(jsonText) {
    // Strip my text
    var stripedText = jsonText.replace(/(\r\n|\n|\r)/gm, '').trim();
    
    /* Get langth of JSON string*/
    var JSONStringLen = stripedText.length;

    var rootCodeBlock = new codeBlock();
    //Set rootCOdeBlock isRoot to true
    rootCodeBlock.isRoot = true;
    
    
    try {
        var parentCodeBlock = new codeBlock();
        var builtObject = new JSONConstructor(parentCodeBlock);
        var json = JSON.parse(jsonText,valueType); 
        var buildjsonCodeBlock = builtObject.buildIterator(parentCodeBlock,json);
            
        var format = '{\n';
        format += formatJSON(buildjsonCodeBlock);
        format += '\n}';

        return format;
        
    } catch (error) {
        //Error message if JSON is invalid
        vscode.window.showErrorMessage('An Error Has Occured: '+error.message);
        console.log(error);
        return false;
    }

}

function valueType(key, value){
    switch (typeof value) {
        case 'string':
            return '"' + String(value) + '"';
            break;
        case 'number':
            return Number(value);
            break;
        default:
            return value;
            break;
    }
}

/**
 * Function return when module in is include in extension
 */
module.exports = function (text) {
    return str(text);
};
