'use strict';

var vscode = require('vscode');

class codeBlock{
    constructor(parentCodeBlock,level){
        this.parentCodeBlock = parentCodeBlock || null; // Will be an object but setting it to null for now
        this.childCodeBlockElements = new Array(); // Array of codeBlockElements objects
        this.level = level || 1;// block level
    }
}


class codeBlockElements {
    constructor(){
        this.key = null; // String value
        //keyname string
        this.value = null; //Sting of the value
        this.codeBlockValue = null; // Will be object but set to null for now
        this.isRoot = false;// Is root element
        this.blockType = null; // Type of block (array or object)
        this.parentCodeBlock = null; // Not referenced in build loop
        this.level = 1;// block level
        this.childLevels = 0;// Count children blocks 
    }
    set key(keyname){//remove keyname with only numbers

        if(typeof keyname == 'string' && keyname.search(/^[0-9]*$/) == -1){
            this._key = keyname;
        }else {
            this._key = null;
        }
        return;
    }
    get key(){
        return this._key;
    }
    set value(value){
        if(typeof value == "string"){
            this._value = escapeString(value);
        }else{
            this._value = value;
        }
        return;
    }
    get value(){
        return this._value;
    }
    set blockType(property){
        var blockType;
        var objectType = Object.prototype.toString.call(property);
        var regex = /[[a-zA-z]+ ([a-zA-z]+)]/;//RegEpx to finf value type from [object (String)]
        if((blockType = regex.exec(objectType)) !== null){
            this._blockType = blockType[1];// String, Array, or Object
        }
    }
    get blockType(){
        return this._blockType;
    }
    rootCodeBlock(){
        var rootCodeBlock = this.parentCodeBlock;
        var root = false;
        /**/
        while (root == false) {
            if(rootCodeBlock.parentCodeBlock !== null){
               rootCodeBlock = rootCodeBlock.parentCodeBlock; 
            }else{
                var root = true;
            }
        }
        return rootCodeBlock;
    }
    hasChild(codeBlockValue){
        var codeVal = this.codeBlockValue || codeBlockValue;
        var codeBlk = false;
        var level = 0;
        var child;
        if(codeVal.childCodeBlockElements.length > 0){
            for (let ix = 0; ix < codeVal.childCodeBlockElements.length; ix++) {
                const element = codeVal.childCodeBlockElements[ix];
                if(element.codeBlockValue !== null){
                    codeBlk = true;
                    break;

                }
            }

        return codeBlk;
        //return new Array(child,level);
    }
    }
}

class JSONConstructor {
    
    constructor(rootCodeBlock){
        this.rootCodeBlock = rootCodeBlock;
    }
    //JSON Parser function
    buildIterator(useCodeBlock,object) {
        for (var property in object) {
            if (object.hasOwnProperty(property)) {
                var newCodeBlockElement = this.createCodeBlockElement(useCodeBlock,object,property);
                if(newCodeBlockElement){                    
                    this.buildIterator(newCodeBlockElement,object[property]);// If childeren blocks
                }
            }
        }
        return useCodeBlock;
    }
    createCodeBlock(useCodeBlock,currentCodeBlockElement){
        var newCodeBlock = new codeBlock();//New codeBlock object
        newCodeBlock.parentCodeBlock = currentCodeBlockElement;// Set propery to referance parent codeBlock
        currentCodeBlockElement.childLevels = currentCodeBlockElement.childLevels + 1;
        newCodeBlock.level = useCodeBlock.level + 1;//Set clodeBlockElement level plus 1
        

        return newCodeBlock;
    }
    createCodeBlockElement(useCodeBlock,obj,prop){
        var objectType = Object.prototype.toString.call(obj[prop]);

        var currentCodeBlockElement = new codeBlockElements();// Create new codeBlockElement
        currentCodeBlockElement.key = prop;
        
        if(currentCodeBlockElement.key != null){
            currentCodeBlockElement.keyLength = (prop.length+2);//Assume quotes as apart of length
        }else{
            currentCodeBlockElement.keyLength = 0;
        }

        currentCodeBlockElement['is'+(prop.charAt(0).toUpperCase() + prop.slice(1)).replace('-','')] = true;// Dynamic isKeyname property

        currentCodeBlockElement.blockType = obj[prop];// Get object type
        
        currentCodeBlockElement.parentCodeBlock = useCodeBlock;
        currentCodeBlockElement.level = useCodeBlock.level;// Block level
        currentCodeBlockElement.value = obj[prop];//
        
        if(objectType === '[object Object]' || objectType === '[object Array]'){
            currentCodeBlockElement.value = null;//set to null if codeBlockElement
            var newCodeBlock = this.createCodeBlock(useCodeBlock,currentCodeBlockElement);
            currentCodeBlockElement.codeBlockValue = newCodeBlock;// Add new codeBlockElement
        }

        useCodeBlock.childCodeBlockElements.push(currentCodeBlockElement);// Add codeBlockElement to parent codeBlock object

        return newCodeBlock || null;
    }
}

//Find the deepest level in JSON
//It's really crud sorry. I thought to simply use a static var to store every increment in the level.
//It bad becuase...well it just seem like it.
class deepestLevel{
    constructor(){
        this._level = 0;
    }

    find(jsonCodeBlock){
        for (var i = 0, elementCount = jsonCodeBlock.childCodeBlockElements.length; i < elementCount; i++) {

            var currentElement = jsonCodeBlock.childCodeBlockElements[i]; // Current Object
            var currentLevel = currentElement.level; // Current Level Block
            var currentColonPosition = currentElement.keyLength;// keyname length
            
            if(this._level < currentLevel){
                this._level = currentLevel;
            }

            /*Children*/
            if(currentElement.codeBlockValue !== null && currentElement.codeBlockValue.childCodeBlockElements.length > 0){
                this.find(currentElement.codeBlockValue);
            }
            
            
        }
    }
    static get level() { return _level; }
    static set level(value) { _level = value; }
}

//Look into the children array
class formatOutput {
    constructor(jsonCodeBlock,deepestLevel) {
        this.jsonCodeBlock = jsonCodeBlock;
        this.generateJSONString = '';
        this.specialFormatKeys = [ //Special formating keyname
        'isTasks',
        'isHappening',
        'isGoals',
        'isAllOf',
        'isChoices',
        'isChoice',
        'isXchoices',
        'isForeignKeys',
        'isSerialize',
        'isIndexes',
        'isAllof',
        'isContextValues',
        'isComputeds',
        'isOneOf'
        ];
        this.deepestLevel = deepestLevel || null;
    }
    
    build(){
        for (var i = 0, elementCount = this.jsonCodeBlock.childCodeBlockElements.length; i < elementCount; i++) {

            var currentElement = this.jsonCodeBlock.childCodeBlockElements[i]; // Current Object
            var parentLevel = null;
            // Parent Level Block
            if(currentElement.parentCodeBlock.parentCodeBlock !== null){
                parentLevel = currentElement.parentCodeBlock.parentCodeBlock.level;
            }
            var currentLevel = currentElement.level; // Current Level Block
            var currentColonPosition = currentElement.keyLength+1;// keyname length
            var currentElementProp = Object.getOwnPropertyNames(currentElement);//Get properties

            
            var setStartColumn = 20;// Starting keyname column position

            if(currentLevel > 1){
                var addSpc = 0;
                for (let s = 0; s < (currentLevel-1); s++) {
                    addSpc += 4;
                    
                }
                setStartColumn = setStartColumn + addSpc;
            }

            //length of padding (currentElements keyname length minus largest value in codeBlock.Children.level)
            var lengthOfPadding = Math.abs(currentColonPosition - setStartColumn);
            
            //Detirmin added spacing on starting colon position
            if(setStartColumn > 36 && currentElement.key){
               
            }
            
            

            var leftSpace = '';
            for (let l = 0; l < lengthOfPadding; l++) {// Loop over padding length add space for each count
                leftSpace += ' '; 
            }

            /**
             * Keyname building
             */
            if(currentElement.key){// Check if key is set leftSpace + '"' + currentElement.key + '": ';
                this.generateJSONString += leftSpace + '"' + currentElement.key + '": ';
            }//leftSpace + '"' + currentElement.key + '_' + currentElement.level + '>' + setStartColumn + '": ';

            /**
             * Value building
             */
            if(currentElement.value !== null){// Check if value set
                this.generateJSONString += currentElement.value;
                this.generateJSONString += newline(i,elementCount,currentElement.key);
            }
    
            /*Children*/
            if(currentElement.codeBlockValue !== null && currentElement.codeBlockValue.childCodeBlockElements.length > 0){
                
                if(currentElement.blockType == 'Array'){
                    //Opening bracket
                    if(isKeyname(currentElementProp,this.specialFormatKeys)){
                        this.generateJSONString += '[\n';
                    }else{
                        if(!currentElement.key){
                            //var reduceSpace = leftSpace.substring(0,(leftSpace.length-6));
                            this.generateJSONString += ''.padEnd(setStartColumn-4);
                        }
                        this.generateJSONString += '[';
                    }
                    var formatJSON = new formatOutput(currentElement.codeBlockValue);
                    this.generateJSONString += formatJSON.build();

                    //Closing bracket
                    if(isKeyname(currentElementProp,this.specialFormatKeys)){
                        if(currentElement.key){
                            var newSpacecurrent = Math.ceil((currentColonPosition/2)); 
                            this.generateJSONString += ''.padEnd(4);
                        }
                        this.generateJSONString += leftSpace;
                    }

                    this.generateJSONString += ']';
                    this.generateJSONString += newline(i,elementCount,true);
    
                }
    
                if(currentElement.blockType == 'Object'){
                    //Space for OPENING object with no keyname

                    if(!currentElement.key){
                        this.generateJSONString += ''.padEnd(setStartColumn);
                    }
    
                    this.generateJSONString += '{\n'; // Open Bracket

                    if(true){// For debugging
                        var formatJSON = new formatOutput(currentElement.codeBlockValue);
                        this.generateJSONString += formatJSON.build();
                    }
                    //Space for CLOSING object with no keyname
                    if(!currentElement.key){
                        this.generateJSONString += ''.padEnd((setStartColumn-4));// Special formatting
                    }else{


                        if(setStartColumn == 36 && currentElement.key){
                            if((i+1) < elementCount){
                                if(currentElement.key){// Does key only have numbers?
                                    
                                }
                            }else {
                                if(currentElement.key){// Does key only have numbers?
                                    
                                }
                            }
                        }
                        if(setStartColumn == 32 && currentElement.key){
                            if((i+1) < elementCount){
                                if(currentElement.key){// Does key only have numbers?
                                    
                                }
                            }else {
                                if(currentElement.hasChild() == false){
                                    
                                }
                                
                            }
                        }
                        if(setStartColumn == 28 && currentElement.key){
                            if((i+1) < elementCount){
                                if(currentElement.key){// Good
                                    
                                }
                            }
                        }
                        var addSpace = '';
                        var byLevel = currentLevel;
                        for (let g = 0; g < byLevel; g++) {
                            addSpace += '      ';
                        }
                        this.generateJSONString += addSpace;
                    }
                    
                    
                    this.generateJSONString += '}';
                    this.generateJSONString += newline(i,elementCount,true);
                }
                
            }
            
            
        }
    
        return this.generateJSONString;
    }
    
    
}

function newline(index, length, boolean) {
    var returnStr;
    if((index+1) < length){
        if(boolean){// Does key only have numbers?
            returnStr = ',\n';
        }else {
            returnStr = ', ';
        }
    } else {
        if(boolean){// Does key only have numbers?
            returnStr = '\n';
        }else {
            returnStr = ' ';
        }
    }
    return returnStr;
}

function isKeyname(properties,specialFormatKeys) {
    for (var key in specialFormatKeys) {
        var found = properties.indexOf(specialFormatKeys[key]);
        if(found > -1) return true;
    }
}

function escapeString(value) {
    return value.replace(/\n/g, "\\n")
        .replace(/\r/g, "\\r")
        .replace(/\t/g, "\\t")
        .replace(/\f/g, "\\f");
        //.replace(/\&/g, "\\&")
}

function valueType(key, value){
    switch (typeof value) {
        case 'string':
            return '"' + String(value) + '"';
            break;
        case 'number':
            return Number(value);
            break;
        default:
            return value;
            break;
    }
}


function str(jsonText) {
    // Strip my text
    var stripedText = jsonText.replace(/(\r\n|\n|\r)/gm, '').trim();
    
    /* Get langth of JSON string*/
    var JSONStringLen = stripedText.length;

    var rootCodeBlock = new codeBlock();
    //Set rootCOdeBlock isRoot to true
    rootCodeBlock.isRoot = true;
    
    
    try {            
        var parentCodeBlock = new codeBlock();
        var builtObject = new JSONConstructor(parentCodeBlock);
        var json = JSON.parse(jsonText,valueType); 
        var buildjsonCodeBlock = builtObject.buildIterator(parentCodeBlock,json);

        var getLevel = new deepestLevel();
        getLevel.find(buildjsonCodeBlock);//Get deepest level
        var foundLevel = getLevel._level;

        var formatJSON = new formatOutput(buildjsonCodeBlock,foundLevel);

        var format = '{\n';
        format += formatJSON.build(buildjsonCodeBlock);
        format += '}';

        return format;
        
    } catch (error) {
        //Error message if JSON is invalid
        vscode.window.showErrorMessage('An Error Has Occured: '+error.message);
        console.log(error);
        return false;
    }

}

function valueType(key, value){
    switch (typeof value) {
        case 'string':
            return '"' + String(value) + '"';
            break;
        case 'number':
            return Number(value);
            break;
        default:
            return value;
            break;
    }
}

/**
 * Function return when module in is include in extension
 */
module.exports = function (text) {
    return str(text);
};
